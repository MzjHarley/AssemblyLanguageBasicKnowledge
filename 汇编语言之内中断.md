---
title: 汇编语言之内中断
date: 2021-08-20 12:31:10
author: MZJ
---
# 内中断
## 引言
中断是CPU处理外部突发事件的一个重要技术。  
它能使CPU在运行时对外部事件发出的中断请求进行及时的处理，处理完成后又立即返回断点，继续CPU原来的工作。  
引起中断的原因或者发出中断的来源称为中断源。根据中断源的不同可以把中断分为硬件中断和软件中断两大类，而硬件中断又分为外部中断和内部中断。  
### 外部中断
一般是指由计算机外设发出的中断请求，如：键盘中断、打印机中断、定时器中断等。外部中断是可以屏蔽的中断，也就是说利用中断控制器可以屏蔽这些外部设备的中断请求。
### 内部中断
是指因硬件出错(如突然断电，奇偶校验错等)或运算出错(除数为零、运算溢出、单步中断等)所引起的中断，是不可屏蔽的中断。
### 软件中断
软件中断并非真正的中断，它们只是可被调用执行的一般程序以及DOS的系统功能调用(int 21H)等都是软件中断。  
>CPU为了处理并发的中断请求，规定了中断的优先权，中断优先权由高到低为：  
(1)除法错误、溢出中断，软件中断  
(2)不可屏蔽中断  
(3)可屏蔽中断  
(4)单步中断

## 中断处理程序
CPU的设计者必须在**中断信息**和**其处理的程序的入口地址**之间建立某种联系，使得CPU可以根据中断信息找到要执行的处理程序。  
中断信息中包含标识中断的类型码。据CPU设计，**中断类型码的作用是用来定位中断处理程序**。  

若要定位中断处理程序，需要知道它的段地址和偏移地址，但如何根据8位的中断类型码(8086中断码为1个字节)得到中断处理程序的段地址和偏移地址呢？这就需要引入“中断向量表”。  
## 中断向量表
CPU用8位的中断类型码通过中断向量表找到相应中断处理程序的入口地址。  
中断向量表就是中断向量的列表。  
中断向量表在内存中保存，存放了256个中断源所对应的中断处理程序的入口。  
对于8086PC机，中断向量表指定放在内存地址0处。  
从内存0000:0000到0000:03FF的1024(256 * 4)个字节单元中存放着中断向量表。  
在这块内存中，高地址字存放段地址，低地址字存放偏移地址。  

我们可以用中断类型码在中断向量表中找到中断处理程序的入口地址，用它来设置CS和IP，使CPU执行中断处理程序。  
**用中断类型码找到中断向量并用它设置CS和IP**的工作是由CPU的硬件自动完成的。CPU完成的这个工作的过程被称为中断过程。  
>8086CPU的中断过程:  
>(1)从中断信息中取得中断类型码  
>(2)标志寄存器的值入栈(保护标志位)  
>(3)设置标志寄存器的第8位TF和第9位IF的值为0  
>(4)CS的内容入栈  
>(5)IP的内容入栈  
>(6)从内存地址为中断类型码 * 4和中断类型码 * 4+2的两个字单元中读取中断处理的程序入口地址来设置IP和CS  
>>更简洁的描述：  
>>(1)从中断信息中取得中断类型码N  
>>(2)pushf  
>>(3)TF=0，IF=0  
>>(4)push CS  
>>(5)push IP  
>>(6)(IP)=(N * 4)，(CS)=(N * 4+2)  

由于CPU随时都可能检测到中断信息，也就是说，CPU随时都有可能执行中断处理程序，所以中断处理程序必须一直存储在内存中的某段空间之中。  
而中断处理程序的入口地址即中断向量，必须存储在相应的中断向量表表项中。  
中断处理程序的编写方法和子程序的比较相似，下面是常规的步骤：  
>常规步骤：  
>(1)保存用的的寄存器（CS,IP,flag）  
>(2)处理中断  
>(3)恢复用到的寄存器  
>(4)用iret指令返回  
>>iret指令的功能用汇编语法描述为：  
>>pop IP  
>>pop CS  
>>popf

iret通常和硬件自动完成的中断过程配合使用。  
可以看出在中断过程中寄存器的入栈顺序和出栈顺序是相对应的,实现了 用 执行中断处理程序前的CPU现场 恢复标志寄存器和CS、IP的工作。  
iret指令执行后，CPU回到执行中断处理程序前的执行点继续执行程序。
## 除法错误中断的处理
除法错误的中断处理即0号中断。  
当CPU执行div除法指令时，若发生除法溢出错误，将产生中断类型码为0的中断信息，CPU将检测这个信息，然后引发中断过程，转去执行0号中断所对应的中断处理程序。
### 示例系统对0号中断的处理
由于DOS和DOSBOX工作台的问题，我们无法展示具体的中断处理。  
但可以肯定的是一旦出现除法错误，那么系统一定会中断程序，并报出出错信息。
## 编程处理0号中断
我们尝试改变0号中断处理程序的功能，它的功能是在屏幕中间显示“overflow!”，然后返回操作系统。
### 程序分析
#### 一、当发生除法溢出时时，产生0号中断信息，从而引发中断过程
>此时CPU进行以下工作：  
>1.取得中断类型码0  
>2.pushf,TF=0,IF=0  
>3.push CS  
>4.push IP  
>5.(IP)=(0 * 4),(CS)=(0 * 4+2)

#### 二、当中断0发生时，CPU将转去执行中断处理程序
>按照如下步骤编写中断处理程序：  
>1.相关处理  
>2.向显示缓冲区送入字符串“overflow!”  
>3.返回DOS  

这个程序我们称为do0.
#### 三、将do0放入内存中
因为除法溢出随时可以发生，CPU随时都有可能将CS和IP指向do0的入口，执行程序。  
那么do0应该放入哪里呢？  
由于我们是在操作系统之上使用计算机，所有硬件的资源都在操作系统的管理之下，所以我们想要得到一块内存存放do0，需要向操作系统申请。但我们不会这么做：在可能的情况下，我们不去理会操作系统，而是直接面向硬件资源。  
我们前面说到内存中0000:0000 ~ 0000:03FF大小为1024个字节空间是系统存放中断处理程序入口的中断向量表的空间。一般情况下，0000:0200到0000:02FF的256个字节的空间所对应的中断向量表表项都是空的，操作系统和其他应用程序都不占用。  
我们可以将do0放到0000:0200 ~ 0000:02FF中。  
#### 四、如果将do0放入到到0000:0200后，发生除法溢出时，CPU转去执行do0，则必须在中断向量表中登记do0的入口地址。
因为除法溢出所对应的中断类型码为0，它的中断处理程序的入口地址应该在内存单元0 * 4和0 * 4+2处存放。
#### 总结
>步骤：  
>1.编写可以显示“overflow!”的中断处理程序do0  
>2.将do0送入内存0000:0200中  
>3.将do0的入口地址0000:0200存储在中断向量表0号表项中。  
>>程序框架：  
>>assume cs:codesg  
>>codesg segment  
>>start:  
>>>do0安装程序  
>>>设置中断向量表  
>>>mov ax,4c00H  
>>>int 21H  
>>  
>>do0:  
>>>显示字符串“overflow!”  
>>>mov ax,4c00H  
>>>int 21H  
>>>  
>>codesg ends  
>>end start  

从上述可以看出程序分为两部分：  
>(1)安装do0，设置中断向量的程序  
>(2)do0  

程序执行时，do0的代码是不执行的，它只是作为do0安装程序所要传输的数据，执行do0安装程序将do0的代码拷贝到内存0000:0200处，后设置中断向量表,即将偏移地址200和段地址0保存在0号表项中，完成后程序返回。  
程序目的：在0000:0200安装内存do0代码，将0号中断处理程序的入口地址设置为0000:0200。  
do0的代码虽然在程序中但并不执行。它是在发生除法溢出时才得以执行。  
do0中的最后两行代码是用来返回dos。  
>更详细的框架:  
>assume cs:codesg  
>codesg segment  
>start:  
>>mov ax,cs  
>>mov ds,cs  
>>mov si,offset do0     ;设置ds:si指向源地址  
>>mov ax,0  
>>mov es,ax  
>>mov di,200H     ;设置es:di指向目的地址  
>>mov cx,offset do0end - offset do0  ;设置cx为传输长度  
>>cld ;设置传输方向为正  
>>rep movsb  
>>设置中断向量表  
>>mov ax,4c00H  
>>int 21H  
>>  
>do0:  
>>显示字符串“overflow!”  
>>mov ax,4c00H  
>>int 21H  
>>  
>do0end: nop  
>codesg ends  
>end start  

我们利用编译器来计算do0的长度。"-"是编译器识别的运算符号，编译器可以用它来进行两个常数的减法，这也是我们利用编译器进行计算程序长度的依据。  
### 程序如下
```assembly
assume cs:codesg
codesg segment
start:
;========安装do0=========
mov ax,cs
mov ds,ax
mov si,offset do0
mov ax,0
mov es,ax
mov di,200H
mov cx,offset do0end - offset do0
cld 
rep movsb
;======设置中断向量表=======
mov ax,0
mov es,ax
mov word ptr es:[0*4],200H
mov word ptr es:[0*4+2],0
;======================
mov ax,4c00H
int 21H
;========编程do0=========
do0:jmp short do0start
       db 'overflow'
;这里我们不将'overflow'放入在数据段内是因为程序执行完后会返回，它所占用的内存空间会被释放，导致数据段中'overflow'可能会被别的信息覆盖。因此要将它存放在一段不会被覆盖的内存空间中即do0所在内存中。
do0start:
       mov ax,cs
       mov ds,ax
       mov si,202H    ;ds:si指向字符串
;程序执行过程中若发生除法溢出时，那么根据中断过程，cs存放了do0程序的段地址，由于jmp short do0start占了两个字节，故字符串的偏移地址为200+2.
       mov ax,0B800H
       mov es,ax
       mov di,12*160+72
       mov cx,8
    s:  
       mov al,[si]
       mov es:[di],al
       mov byte ptr es:[di+1],2H
       inc si
       add di,2
    loop s
mov ax,4c00H
int 21H
do0end:nop
;=======================
codesg ends
end start
```
## 单步中断
CPU在执行完一条指令之后，如果检测到标志寄存器的TF位为1，则产生单步中断，引发中断过程。   
>单步中断的中断类型码为1，则它所引起的中断过程如下：  
>(1)取得中断类型码1  
>(2)标志寄存器入栈，TF=0,IF=0  
>(3)push CS  
>(4)push IP  
>(5) (CS)=(1 * 4+2),(IP)=(1 * 4)  

debug提供了单步中断的中断处理程序，功能为显示所有寄存器中的内容后等待输入命令。  
使用debug -t时，debug会将TF设置为1，使得CPU在执行完这条指令会引发单步中断过程。
### 在这里解释下：为什么在中断过程中要设置IF和TF=0？
设置IF=0是使CPU在执行中断处理程序的过程中，禁止CPU响应外中断的可屏蔽中断（不能处理中断中再产生中断）。  
我们知道执行单步中断前TF=1，机器进入单步工作状态，当执行到中断处理程序的第一条指令时(此时TF=1)产生单步中断,从而引发单步中断过程，这样会陷入一个死循环，永远执行中断处理程序的第一条指令。这样是错误的。我们应在执行中断处理程序前设置TF=0，从而让CPU连续工作执行中断处理程序。  
## 响应中断中的特殊情况
一般情况下，CPU在执行当前指令后，如果检测到中断信息，就响应中断，引发中断过程。  
但是存在特殊情况，CPU在发生中断时，也不会响应。  
例如：**在执行完向SS寄存器传送数据的指令后，即便是检测到中断信号，CPU也不会相应。**  
主要原因：SS:SP指向栈顶，而对它们的设置应该是连续完成的。因为在执行完向SS寄存器传送数据的指令后，CPU若响应中断引发中断过程，会将flag、CS、IP的值压栈。SS改变，SP并未改变，导致SS:SP并未指向栈顶，则引发错误。  
我们应该利用这个特性将设置SS和SP的指令连续存放，使得设置SP的指令紧接着设置SS的指令执行，而在此之间，CPU不会引发任何中断过程。

## 内中断结束
